import pytest
from datetime import datetime

from sentinel_brain.data.exploits import (
    ExploitRegistry,
    Exploit,
    AttackVector,
    Network,
    Detectability,
    TrainingPriority,
)


class TestExploit:
    def test_exploit_creation(self):
        exploit = Exploit(
            id="test_exploit",
            protocol="Test Protocol",
            date=datetime(2024, 1, 1),
            amount_usd=1_000_000,
            network=Network.ETHEREUM,
            attack_vector=AttackVector.FLASH_LOAN,
            detectability=Detectability.HIGH,
            training_priority=TrainingPriority.P0_CRITICAL,
        )
        assert exploit.id == "test_exploit"
        assert exploit.protocol == "Test Protocol"
        assert exploit.amount_usd == 1_000_000
        assert exploit.network == Network.ETHEREUM

    def test_is_trainable_high_detectability(self):
        exploit = Exploit(
            id="test",
            protocol="Test",
            date=datetime(2024, 1, 1),
            amount_usd=1_000_000,
            network=Network.ETHEREUM,
            attack_vector=AttackVector.FLASH_LOAN,
            detectability=Detectability.HIGH,
            training_priority=TrainingPriority.P0_CRITICAL,
        )
        assert exploit.is_trainable is True

    def test_is_trainable_medium_detectability(self):
        exploit = Exploit(
            id="test",
            protocol="Test",
            date=datetime(2024, 1, 1),
            amount_usd=1_000_000,
            network=Network.ETHEREUM,
            attack_vector=AttackVector.BRIDGE_EXPLOIT,
            detectability=Detectability.MEDIUM,
            training_priority=TrainingPriority.P1_HIGH,
        )
        assert exploit.is_trainable is True

    def test_is_trainable_low_detectability(self):
        exploit = Exploit(
            id="test",
            protocol="Test",
            date=datetime(2024, 1, 1),
            amount_usd=1_000_000,
            network=Network.ETHEREUM,
            attack_vector=AttackVector.PRIVATE_KEY_COMPROMISE,
            detectability=Detectability.LOW,
            training_priority=TrainingPriority.P2_MONITOR,
        )
        assert exploit.is_trainable is False

    def test_amount_millions(self):
        exploit = Exploit(
            id="test",
            protocol="Test",
            date=datetime(2024, 1, 1),
            amount_usd=197_000_000,
            network=Network.ETHEREUM,
            attack_vector=AttackVector.FLASH_LOAN,
            detectability=Detectability.HIGH,
            training_priority=TrainingPriority.P0_CRITICAL,
        )
        assert exploit.amount_millions == 197.0

    def test_optional_fields_default_values(self):
        exploit = Exploit(
            id="test",
            protocol="Test",
            date=datetime(2024, 1, 1),
            amount_usd=1_000_000,
            network=Network.ETHEREUM,
            attack_vector=AttackVector.FLASH_LOAN,
            detectability=Detectability.HIGH,
            training_priority=TrainingPriority.P0_CRITICAL,
        )
        assert exploit.block_number is None
        assert exploit.tx_hash is None
        assert exploit.attacker_address is None
        assert exploit.target_contracts == []
        assert exploit.description == ""
        assert exploit.tags == []


class TestExploitRegistry:
    @pytest.fixture
    def registry(self):
        return ExploitRegistry()

    def test_registry_loads_exploits(self, registry):
        assert registry.count() > 0

    def test_registry_has_minimum_exploits(self, registry):
        assert registry.count() >= 70

    def test_get_existing_exploit(self, registry):
        euler = registry.get("euler_2023")
        assert euler is not None
        assert euler.protocol == "Euler Finance"
        assert euler.amount_usd == 197_000_000
        assert euler.network == Network.ETHEREUM
        assert euler.attack_vector == AttackVector.FLASH_LOAN

    def test_get_nonexistent_exploit(self, registry):
        result = registry.get("nonexistent_exploit")
        assert result is None

    def test_get_all_returns_list(self, registry):
        all_exploits = registry.get_all()
        assert isinstance(all_exploits, list)
        assert len(all_exploits) == registry.count()

    def test_get_by_network_ethereum(self, registry):
        eth_exploits = registry.get_by_network(Network.ETHEREUM)
        assert len(eth_exploits) > 0
        for exploit in eth_exploits:
            assert exploit.network == Network.ETHEREUM

    def test_get_by_network_arbitrum(self, registry):
        arb_exploits = registry.get_by_network(Network.ARBITRUM)
        assert len(arb_exploits) > 0
        for exploit in arb_exploits:
            assert exploit.network == Network.ARBITRUM

    def test_get_by_attack_vector_flash_loan(self, registry):
        flash_loan_exploits = registry.get_by_attack_vector(AttackVector.FLASH_LOAN)
        assert len(flash_loan_exploits) > 0
        for exploit in flash_loan_exploits:
            assert exploit.attack_vector == AttackVector.FLASH_LOAN

    def test_get_by_attack_vector_reentrancy(self, registry):
        reentrancy_exploits = registry.get_by_attack_vector(AttackVector.REENTRANCY)
        assert len(reentrancy_exploits) > 0
        for exploit in reentrancy_exploits:
            assert exploit.attack_vector == AttackVector.REENTRANCY

    def test_get_by_attack_vector_oracle(self, registry):
        oracle_exploits = registry.get_by_attack_vector(AttackVector.ORACLE_MANIPULATION)
        assert len(oracle_exploits) > 0
        for exploit in oracle_exploits:
            assert exploit.attack_vector == AttackVector.ORACLE_MANIPULATION

    def test_get_by_detectability_high(self, registry):
        high_detect = registry.get_by_detectability(Detectability.HIGH)
        assert len(high_detect) > 0
        for exploit in high_detect:
            assert exploit.detectability == Detectability.HIGH

    def test_get_by_detectability_low(self, registry):
        low_detect = registry.get_by_detectability(Detectability.LOW)
        assert len(low_detect) > 0
        for exploit in low_detect:
            assert exploit.detectability == Detectability.LOW

    def test_get_by_priority_p0(self, registry):
        p0_exploits = registry.get_by_priority(TrainingPriority.P0_CRITICAL)
        assert len(p0_exploits) > 0
        for exploit in p0_exploits:
            assert exploit.training_priority == TrainingPriority.P0_CRITICAL

    def test_get_trainable(self, registry):
        trainable = registry.get_trainable()
        assert len(trainable) > 0
        for exploit in trainable:
            assert exploit.detectability in (Detectability.HIGH, Detectability.MEDIUM)

    def test_get_by_year_2023(self, registry):
        exploits_2023 = registry.get_by_year(2023)
        assert len(exploits_2023) > 0
        for exploit in exploits_2023:
            assert exploit.date.year == 2023

    def test_get_by_year_2024(self, registry):
        exploits_2024 = registry.get_by_year(2024)
        assert len(exploits_2024) > 0
        for exploit in exploits_2024:
            assert exploit.date.year == 2024

    def test_get_by_year_2022(self, registry):
        exploits_2022 = registry.get_by_year(2022)
        assert len(exploits_2022) > 0
        for exploit in exploits_2022:
            assert exploit.date.year == 2022

    def test_get_with_tx_hash(self, registry):
        with_tx = registry.get_with_tx_hash()
        assert len(with_tx) > 0
        for exploit in with_tx:
            assert exploit.tx_hash is not None

    def test_get_with_block_number(self, registry):
        with_block = registry.get_with_block_number()
        assert len(with_block) > 0
        for exploit in with_block:
            assert exploit.block_number is not None

    def test_get_by_tag_flash_loan(self, registry):
        flash_loan_tagged = registry.get_by_tag("flash_loan")
        assert len(flash_loan_tagged) > 0
        for exploit in flash_loan_tagged:
            assert "flash_loan" in exploit.tags

    def test_get_by_tag_bridge(self, registry):
        bridge_tagged = registry.get_by_tag("bridge")
        assert len(bridge_tagged) > 0
        for exploit in bridge_tagged:
            assert "bridge" in exploit.tags

    def test_get_by_min_amount(self, registry):
        large_exploits = registry.get_by_min_amount(100_000_000)
        assert len(large_exploits) > 0
        for exploit in large_exploits:
            assert exploit.amount_usd >= 100_000_000

    def test_total_losses(self, registry):
        total = registry.total_losses()
        assert total > 0
        assert total > 1_000_000_000

    def test_summary_by_attack_vector(self, registry):
        summary = registry.summary_by_attack_vector()
        assert len(summary) > 0
        assert AttackVector.FLASH_LOAN in summary
        flash_loan_summary = summary[AttackVector.FLASH_LOAN]
        assert "count" in flash_loan_summary
        assert "total_usd" in flash_loan_summary
        assert "avg_usd" in flash_loan_summary
        assert flash_loan_summary["count"] > 0

    def test_summary_by_year(self, registry):
        summary = registry.summary_by_year()
        assert len(summary) > 0
        assert 2022 in summary
        assert 2023 in summary
        assert 2024 in summary
        for year, data in summary.items():
            assert "count" in data
            assert "total_usd" in data
            assert "high_detectability" in data


class TestKnownExploits:
    @pytest.fixture
    def registry(self):
        return ExploitRegistry()

    def test_euler_exploit_details(self, registry):
        euler = registry.get("euler_2023")
        assert euler is not None
        assert euler.block_number == 16817996
        assert euler.tx_hash == "0xc310a0affe2169d1f6feec1c63dbc7f7c62a887fa48795d327d4d2da2d6b111d"
        assert euler.attacker_address == "0xb66cd966670d962c227b3eaba30a872dbfb995db"
        assert "lending" in euler.tags
        assert "flash_loan" in euler.tags

    def test_curve_exploit_details(self, registry):
        curve = registry.get("curve_2023")
        assert curve is not None
        assert curve.attack_vector == AttackVector.COMPILER_BUG
        assert "vyper" in curve.tags
        assert "reentrancy" in curve.tags

    def test_beanstalk_exploit_details(self, registry):
        beanstalk = registry.get("beanstalk_2022")
        assert beanstalk is not None
        assert beanstalk.attack_vector == AttackVector.GOVERNANCE_ATTACK
        assert beanstalk.block_number == 14595905
        assert "governance" in beanstalk.tags
        assert "flash_loan" in beanstalk.tags

    def test_nomad_exploit_details(self, registry):
        nomad = registry.get("nomad_2022")
        assert nomad is not None
        assert nomad.attack_vector == AttackVector.INITIALIZATION_BUG
        assert nomad.detectability == Detectability.HIGH
        assert "bridge" in nomad.tags

    def test_ronin_exploit_details(self, registry):
        ronin = registry.get("ronin_2022")
        assert ronin is not None
        assert ronin.amount_usd == 625_000_000
        assert ronin.detectability == Detectability.LOW
        assert "lazarus" in ronin.tags

    def test_bybit_2025_exploit(self, registry):
        bybit = registry.get("bybit_2025")
        assert bybit is not None
        assert bybit.amount_usd == 1_500_000_000
        assert bybit.attack_vector == AttackVector.SUPPLY_CHAIN
        assert bybit.detectability == Detectability.LOW

    def test_cetus_2025_exploit(self, registry):
        cetus = registry.get("cetus_2025")
        assert cetus is not None
        assert cetus.network == Network.SUI
        assert cetus.attack_vector == AttackVector.ARITHMETIC_OVERFLOW
        assert cetus.detectability == Detectability.HIGH


class TestAttackVectorCoverage:
    @pytest.fixture
    def registry(self):
        return ExploitRegistry()

    def test_has_flash_loan_exploits(self, registry):
        exploits = registry.get_by_attack_vector(AttackVector.FLASH_LOAN)
        assert len(exploits) >= 10

    def test_has_oracle_manipulation_exploits(self, registry):
        exploits = registry.get_by_attack_vector(AttackVector.ORACLE_MANIPULATION)
        assert len(exploits) >= 5

    def test_has_reentrancy_exploits(self, registry):
        exploits = registry.get_by_attack_vector(AttackVector.REENTRANCY)
        assert len(exploits) >= 3

    def test_has_logic_error_exploits(self, registry):
        exploits = registry.get_by_attack_vector(AttackVector.LOGIC_ERROR)
        assert len(exploits) >= 5

    def test_has_bridge_exploits(self, registry):
        exploits = registry.get_by_attack_vector(AttackVector.BRIDGE_EXPLOIT)
        assert len(exploits) >= 2


class TestL2Coverage:
    @pytest.fixture
    def registry(self):
        return ExploitRegistry()

    def test_has_arbitrum_exploits(self, registry):
        arb_exploits = registry.get_by_network(Network.ARBITRUM)
        assert len(arb_exploits) >= 3

    def test_has_optimism_exploits(self, registry):
        op_exploits = registry.get_by_network(Network.OPTIMISM)
        assert len(op_exploits) >= 2

    def test_has_blast_exploits(self, registry):
        blast_exploits = registry.get_by_network(Network.BLAST)
        assert len(blast_exploits) >= 1


class TestTrainingReadiness:
    @pytest.fixture
    def registry(self):
        return ExploitRegistry()

    def test_has_exploits_with_block_numbers(self, registry):
        with_blocks = registry.get_with_block_number()
        assert len(with_blocks) >= 20

    def test_has_exploits_with_tx_hashes(self, registry):
        with_tx = registry.get_with_tx_hash()
        assert len(with_tx) >= 10

    def test_trainable_exploits_sufficient(self, registry):
        trainable = registry.get_trainable()
        assert len(trainable) >= 40

    def test_p0_exploits_have_high_detectability(self, registry):
        p0_exploits = registry.get_by_priority(TrainingPriority.P0_CRITICAL)
        for exploit in p0_exploits:
            assert exploit.detectability == Detectability.HIGH
