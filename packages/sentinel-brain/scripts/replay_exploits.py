#!/usr/bin/env python3
from __future__ import annotations

import argparse
import asyncio
import json
import os
import sys
from pathlib import Path

import structlog

sys.path.insert(0, str(Path(__file__).parent.parent / "src"))

from sentinel_brain.data.exploits import ExploitRegistry, Detectability
from sentinel_brain.data.collectors.fork_replayer import ForkReplayer
from sentinel_brain.features.aggregator import FeatureAggregator
from sentinel_brain.inference.engine import InferenceEngine


logger = structlog.get_logger()


async def replay_single_exploit(
    replayer: ForkReplayer,
    exploit_id: str,
    registry: ExploitRegistry,
) -> dict | None:
    exploit = registry.get(exploit_id)
    if not exploit:
        logger.error("exploit_not_found", exploit_id=exploit_id)
        return None

    if not exploit.tx_hash:
        logger.warning("exploit_no_tx_hash", exploit_id=exploit_id)
        return None

    logger.info(
        "replaying_exploit",
        exploit_id=exploit_id,
        protocol=exploit.protocol,
        amount_usd=exploit.amount_usd,
        attack_vector=exploit.attack_vector.value,
    )

    try:
        trace = await replayer.replay_exploit(exploit)
        if trace:
            aggregator = FeatureAggregator()
            features = await aggregator.extract_from_trace(trace)

            return {
                "exploit_id": exploit_id,
                "protocol": exploit.protocol,
                "amount_usd": exploit.amount_usd,
                "attack_vector": exploit.attack_vector.value,
                "tx_hash": exploit.tx_hash,
                "block_number": exploit.block_number,
                "trace_summary": {
                    "gas_used": trace.gas_used,
                    "contracts_called": len(trace.contracts_called),
                    "created_contracts": len(trace.created_contracts),
                    "opcodes": trace.opcodes,
                },
                "features": features.to_dict(),
            }
    except Exception as e:
        logger.error("replay_failed", exploit_id=exploit_id, error=str(e))

    return None


async def replay_all_trainable(
    replayer: ForkReplayer,
    registry: ExploitRegistry,
    output_dir: Path,
    max_concurrent: int = 3,
) -> list[dict]:
    trainable = registry.get_trainable()
    with_tx = [e for e in trainable if e.tx_hash and e.block_number]

    logger.info("found_trainable_exploits", count=len(with_tx))

    results: list[dict] = []
    semaphore = asyncio.Semaphore(max_concurrent)

    async def replay_with_semaphore(exploit_id: str) -> dict | None:
        async with semaphore:
            return await replay_single_exploit(replayer, exploit_id, registry)

    tasks = [replay_with_semaphore(e.id) for e in with_tx]
    completed = await asyncio.gather(*tasks, return_exceptions=True)

    for result in completed:
        if isinstance(result, dict):
            results.append(result)

    summary_path = output_dir / "replay_summary.json"
    with open(summary_path, "w") as f:
        json.dump(results, f, indent=2)

    logger.info("replay_complete", successful=len(results), total=len(with_tx))
    return results


async def analyze_exploit(
    engine: InferenceEngine,
    exploit_id: str,
    registry: ExploitRegistry,
) -> dict | None:
    exploit = registry.get(exploit_id)
    if not exploit or not exploit.tx_hash:
        return None

    try:
        trace = await engine.fork_replayer.replay_exploit(exploit)
        if trace:
            result = await engine.analyze_trace(trace)
            return {
                "exploit_id": exploit_id,
                "detected": result.is_suspicious,
                "anomaly_score": result.anomaly_score,
                "risk_level": result.risk_level,
                "risk_indicators": result.risk_indicators,
                "latency_ms": result.latency_ms,
            }
    except Exception as e:
        logger.error("analysis_failed", exploit_id=exploit_id, error=str(e))

    return None


def list_exploits(registry: ExploitRegistry, filter_type: str | None = None) -> None:
    if filter_type == "trainable":
        exploits = registry.get_trainable()
    elif filter_type == "with_tx":
        exploits = registry.get_with_tx_hash()
    else:
        exploits = registry.get_all()

    print(f"\n{'ID':<30} {'Protocol':<25} {'Amount':<15} {'Vector':<25} {'Detectable'}")
    print("-" * 110)

    for e in sorted(exploits, key=lambda x: x.amount_usd, reverse=True):
        amount_str = f"${e.amount_usd / 1e6:.1f}M"
        print(f"{e.id:<30} {e.protocol:<25} {amount_str:<15} {e.attack_vector.value:<25} {e.detectability.value}")

    print(f"\nTotal: {len(exploits)} exploits")
    print(f"Total losses: ${registry.total_losses() / 1e9:.2f}B")


def show_summary(registry: ExploitRegistry) -> None:
    print("\n=== Exploit Registry Summary ===\n")

    print("By Year:")
    for year, data in registry.summary_by_year().items():
        print(f"  {year}: {data['count']} exploits, ${data['total_usd'] / 1e9:.2f}B lost, {data['high_detectability']} high detectability")

    print("\nBy Attack Vector:")
    for vector, data in sorted(
        registry.summary_by_attack_vector().items(),
        key=lambda x: x[1]["total_usd"],
        reverse=True,
    ):
        print(f"  {vector.value:<25}: {data['count']:>3} exploits, ${data['total_usd'] / 1e9:.2f}B lost")

    print(f"\nTotal Exploits: {registry.count()}")
    print(f"Trainable (HIGH/MEDIUM): {len(registry.get_trainable())}")
    print(f"With Transaction Hash: {len(registry.get_with_tx_hash())}")
    print(f"With Block Number: {len(registry.get_with_block_number())}")


async def main_async(args: argparse.Namespace) -> None:
    registry = ExploitRegistry()

    if args.command == "list":
        list_exploits(registry, args.filter)
        return

    if args.command == "summary":
        show_summary(registry)
        return

    if not args.rpc:
        print("Error: --rpc is required for replay commands")
        sys.exit(1)

    output_dir = Path(args.output)
    output_dir.mkdir(parents=True, exist_ok=True)

    replayer = ForkReplayer(
        rpc_url=args.rpc,
        anvil_path=args.anvil or "anvil",
        output_dir=output_dir,
    )

    if args.command == "replay":
        if args.exploit:
            result = await replay_single_exploit(replayer, args.exploit, registry)
            if result:
                print(json.dumps(result, indent=2))
        elif args.all:
            await replay_all_trainable(replayer, registry, output_dir)
        else:
            print("Specify --exploit <id> or --all")

    elif args.command == "analyze":
        if not args.model:
            print("Error: --model is required for analyze command")
            sys.exit(1)

        engine = InferenceEngine(
            rpc_url=args.rpc,
            model_path=args.model,
        )
        await engine.initialize()

        if args.exploit:
            result = await analyze_exploit(engine, args.exploit, registry)
            if result:
                print(json.dumps(result, indent=2))


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Replay and analyze historical DeFi exploits",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    subparsers = parser.add_subparsers(dest="command", help="Commands")

    list_parser = subparsers.add_parser("list", help="List exploits in registry")
    list_parser.add_argument(
        "--filter",
        choices=["trainable", "with_tx"],
        help="Filter exploits",
    )

    summary_parser = subparsers.add_parser("summary", help="Show registry summary")

    replay_parser = subparsers.add_parser("replay", help="Replay exploit transactions")
    replay_parser.add_argument("--exploit", type=str, help="Exploit ID to replay")
    replay_parser.add_argument("--all", action="store_true", help="Replay all trainable exploits")
    replay_parser.add_argument("--rpc", type=str, help="Ethereum RPC URL")
    replay_parser.add_argument("--anvil", type=str, help="Path to anvil binary")
    replay_parser.add_argument("--output", type=str, default="data/traces", help="Output directory")

    analyze_parser = subparsers.add_parser("analyze", help="Analyze exploit with trained model")
    analyze_parser.add_argument("--exploit", type=str, required=True, help="Exploit ID to analyze")
    analyze_parser.add_argument("--rpc", type=str, required=True, help="Ethereum RPC URL")
    analyze_parser.add_argument("--model", type=str, required=True, help="Path to trained model")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    asyncio.run(main_async(args))


if __name__ == "__main__":
    main()
